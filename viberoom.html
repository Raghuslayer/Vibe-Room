<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VibeRoom - Your Private Study Hub</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Great+Vibes&family=Poppins:wght@300;400;500;600;700&display=swap">

  <style>
    /* viberoom.css - Integrated Styles */

    /* General Body and Container Styles (matching login-profile theme) */
    body {
      background: #1a1a2e; /* Dark background for vibe room */
      color: #e0e0e0;
      font-family: 'Poppins', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      overflow: hidden; /* Prevent scroll on main screen */
    }

    #viberoom-container {
      width: 95%;
      max-width: 1400px; /* Increased max-width for better layout */
      height: 95vh;
      display: flex;
      flex-direction: column;
      background-color: #24243e;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      position: relative; /* For RGB border */
      overflow: hidden; /* Ensure content stays within rounded corners */
    }

    /* Utility Classes */
    .hidden {
      display: none !important;
      opacity: 0;
      pointer-events: none;
    }
    .visible {
      display: flex !important; /* Or block, grid, etc. depending on context */
      opacity: 1;
      pointer-events: auto;
    }
    .screen {
      width: 100%;
      height: 100%;
      transition: opacity 0.5s ease-in-out;
    }

    /* Loading Screen (from login-profile, ensure it's copied or linked) */
    #loading-screen {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      z-index: 9999;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: #fff;
      font-size: 3em;
      font-weight: 700;
      letter-spacing: 3px;
      text-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 0 25px rgba(255, 215, 0, 0.6);
      animation: fadeIn 0.5s ease-out forwards;
    }

    #loading-screen.hidden {
      animation: fadeOut 0.5s ease-out forwards;
    }

    #loading-screen .loading-text {
      font-family: 'Great Vibes', cursive; /* Assuming Great Vibes is loaded from login-profile */
      animation: vibingAnimation 2s infinite ease-in-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    @keyframes vibingAnimation {
      0% { transform: scale(1) translateY(0) skewX(0); opacity: 1; text-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 0 25px rgba(255, 215, 0, 0.6); }
      25% { transform: scale(1.02) translateY(-2px) skewX(2deg); opacity: 0.9; text-shadow: 0 0 20px rgba(255, 215, 0, 0.9), 0 0 30px rgba(255, 215, 0, 0.7); }
      50% { transform: scale(1.05) translateY(0) skewX(-2deg); opacity: 1; text-shadow: 0 0 25px rgba(255, 215, 0, 1), 0 0 35px rgba(255, 215, 0, 0.8); }
      75% { transform: scale(1.02) translateY(2px) skewX(2deg); opacity: 0.9; text-shadow: 0 0 20px rgba(255, 215, 0, 0.9), 0 0 30px rgba(255, 215, 0, 0.7); }
      100% { transform: scale(1) translateY(0) skewX(0); opacity: 1; text-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 0 25px rgba(255, 215, 0, 0.6); }
    }

    /* Room Options Screen */
    #room-options-screen {
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 30px;
      padding: 20px;
    }

    .section-title {
      font-size: 2.5em;
      font-weight: 700;
      margin-bottom: 30px;
      color: #fff;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
    }

    .options-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 25px;
      width: 100%;
      max-width: 900px;
    }

    .option-btn {
      background-color: #0f3460;
      color: white;
      border: none;
      padding: 25px 20px;
      border-radius: 12px;
      font-size: 1.4em;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 15px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }

    .option-btn i {
      font-size: 2.5em;
      color: #FFB26B; /* Accent color */
    }

    .option-btn:hover {
      background-color: #16213e;
      transform: translateY(-5px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    }

    .option-btn.coming-soon {
      opacity: 0.7;
      cursor: not-allowed;
      background-color: #3e3e5a;
    }

    .coming-soon-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #d9534f;
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      font-weight: bold;
      transform: rotate(5deg);
    }

    /* Modals (Custom Alert and Private Room Modal) */
    .modal {
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      transition: opacity 0.3s ease;
    }

    .modal-content {
      background-color: #2e2e4a;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
      position: relative;
      width: 90%;
      max-width: 500px;
      color: #e0e0e0;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .modal-title {
      font-size: 2em;
      margin-bottom: 15px;
      color: #FFB26B;
    }

    .close-button {
      position: absolute;
      top: 15px;
      right: 20px;
      font-size: 30px;
      cursor: pointer;
      color: #aaa;
      transition: color 0.2s ease;
    }
    .close-button:hover {
      color: white;
    }

    .modal-section {
      background-color: #3f3f5a;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 15px;
      text-align: left;
    }
    .modal-section:last-child {
      margin-bottom: 0;
    }
    .modal-section h4 {
      font-size: 1.3em;
      margin-bottom: 15px;
      color: #e0e0e0;
      text-align: center;
    }

    .modal-content label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #ccc;
    }

    .modal-content input,
    .modal-content select {
      width: calc(100% - 20px);
      padding: 12px;
      margin-bottom: 15px;
      border-radius: 8px;
      border: 1px solid #4a4a6e;
      background-color: #2a2a4e;
      color: #e0e0e0;
      font-size: 1em;
    }
    .modal-content input::placeholder {
      color: #999;
    }
    .modal-content input:focus,
    .modal-content select:focus {
      outline: none;
      border-color: #FFB26B;
      box-shadow: 0 0 8px rgba(255, 178, 107, 0.4);
    }

    .action-btn {
      background: linear-gradient(90deg, #8A2BE2, #4B0082); /* Purple gradient from login */
      border: none;
      padding: 12px 25px;
      border-radius: 25px;
      color: white;
      font-size: 1.1em;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      width: auto; /* Allow button to size naturally */
      margin: 0 auto; /* Center button */
      display: block; /* Ensure it takes full width if needed, but flex will handle centering */
    }
    .action-btn:hover {
      box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
      transform: translateY(-2px);
    }
    .action-btn.cancel-btn {
      background: #d9534f; /* Red for cancel */
    }
    .action-btn.cancel-btn:hover {
      background: #c9302c;
      box-shadow: 0 0 10px rgba(217, 83, 79, 0.5);
    }

    .modal-buttons {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }

    /* Custom Alert Modal (copied from login-profile.html) */
    .custom-modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.4);
      justify-content: center;
      align-items: center;
    }

    .custom-modal-content {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      margin: auto;
      padding: 20px;
      width: 80%;
      max-width: 300px;
      border-radius: 10px;
      text-align: center;
      color: #fff;
    }

    .custom-modal-content h3 {
      margin-bottom: 15px;
      color: #fff;
      text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
    }

    .custom-modal-content button {
      background: linear-gradient(90deg, #8A2BE2, #4B0082);
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
    }

    .custom-modal-content button:hover {
      box-shadow: 0 0 10px rgba(138, 43, 226, 0.6);
      transform: translateY(-1px);
    }


    /* Video Call Room Screen Layout */
    #video-room-screen {
      display: grid;
      grid-template-rows: auto 1fr; /* Top bar, then main content */
      height: 100%;
      position: relative; /* For RGB border */
      padding: 15px; /* Inner padding for the main layout */
      gap: 15px; /* Gap between top bar and main content */
      overflow: hidden; /* Ensure nothing overflows the room screen */
    }

    /* RGB Glow Border */
    .rgb-glow-border {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 15px;
      pointer-events: none; /* Allows clicks to pass through */
      z-index: 0; /* Behind content */
      box-sizing: border-box; /* Include padding/border in element's total width and height */
      border: 5px solid transparent; /* Initial transparent border */
      background-clip: padding-box; /* Background only applies to padding box */
      animation: rgbGlow 10s linear infinite;
    }

    @keyframes rgbGlow {
      0% { border-color: #ff0000; } /* Red */
      16% { border-color: #ffff00; } /* Yellow */
      33% { border-color: #00ff00; } /* Green */
      50% { border-color: #00ffff; } /* Cyan */
      66% { border-color: #0000ff; } /* Blue */
      83% { border-color: #ff00ff; } /* Magenta */
      100% { border-color: #ff0000; } /* Red */
    }


    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background-color: #16213e;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      z-index: 1; /* Above glow border */
    }
    .top-bar h3 {
      margin: 0;
      color: #e0e0e0;
      font-size: 1.2em;
    }
    .top-bar h3 span {
      font-weight: normal;
      color: #FFB26B;
    }
    .top-bar-actions {
      display: flex;
      gap: 10px;
    }
    .control-btn {
      background-color: #0f3460;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.3s ease;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .control-btn i {
      font-size: 1.1em;
    }
    .control-btn:hover {
      background-color: #16213e;
    }
    .exit-btn {
      background-color: #d9534f; /* Red */
    }
    .exit-btn:hover {
      background-color: #c9302c;
    }
    .end-btn {
      background-color: #f0ad4e; /* Orange */
    }
    .end-btn:hover {
      background-color: #ec971f;
    }


    /* Main content grid for 4 sections */
    .main-room-grid {
      display: grid;
      grid-template-columns: 2fr 1fr; /* Left (video) is 2 parts, right (chat/pomodoro) is 1 part */
      grid-template-rows: 1fr 1fr; /* Top (video/chat), bottom (music/pomodoro) */
      gap: 15px;
      height: 100%; /* Take remaining height */
      overflow: hidden; /* Prevent internal scrolling */
    }

    /* Section Styling */
    .video-feeds-section, .ai-chat-section, .music-player-section, .pomodoro-section {
      background-color: #2a2a4e;
      border-radius: 10px;
      padding: 15px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
    }

    /* Section 1: Video Feeds */
    .video-feeds-section {
      grid-area: 1 / 1 / 3 / 2; /* Spans rows 1 and 2, column 1 */
      display: grid;
      /* Initial grid for 1 person, will be updated by JS */
      grid-template-columns: 1fr;
      grid-template-rows: 1fr;
      gap: 10px;
      justify-content: center;
      align-items: center;
      overflow: hidden; /* Hide scrollbars if videos overflow */
    }

    /* Dynamic grid for video feeds based on number of participants */
    .video-feeds-section[data-participants="1"] {
      grid-template-columns: 1fr;
      grid-template-rows: 1fr;
    }
    .video-feeds-section[data-participants="2"] {
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr;
    }
    .video-feeds-section[data-participants="3"],
    .video-feeds-section[data-participants="4"] {
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
    }


    .video-wrapper {
      position: relative;
      width: 100%;
      height: 100%;
      background-color: #1a1a2e;
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      border: 2px solid transparent; /* For active user indicator */
      transition: border-color 0.3s ease;
    }
    .video-wrapper.active-speaker {
      border-color: #FFB26B; /* Highlight active speaker */
    }

    .video-wrapper video {
      width: 100%;
      height: 100%;
      object-fit: cover; /* Ensures video fills the container */
      border-radius: 8px;
      transform: scaleX(-1); /* Mirror local video */
    }

    .video-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, rgba(0,0,0,0.7), rgba(0,0,0,0));
      padding: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: white;
      font-size: 0.9em;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none; /* Allow clicks to pass through by default */
    }
    .video-wrapper:hover .video-overlay {
      opacity: 1;
      pointer-events: auto; /* Enable interaction on hover */
    }

    .video-username {
      font-weight: 600;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }

    .video-controls-overlay {
      display: flex;
      gap: 8px;
    }
    .video-control-btn {
      background-color: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: background-color 0.3s ease, color 0.3s ease;
      font-size: 0.9em;
      pointer-events: auto; /* Ensure buttons are clickable */
    }
    .video-control-btn:hover {
      background-color: rgba(0, 0, 0, 0.8);
    }
    .video-control-btn.active { /* For when mic/cam is on */
      color: #8BC34A; /* Green */
    }
    .video-control-btn.inactive { /* For when mic/cam is off */
      color: #FF7B54; /* Red */
    }


    /* Section 2: AI Gemini Chatbox */
    .ai-chat-section {
      grid-area: 1 / 2 / 2 / 3; /* Row 1, Column 2 */
      justify-content: space-between;
      overflow: hidden; /* Hide scrollbar for chat messages */
    }
    .ai-chat-section .section-title {
      font-size: 1.5em;
      margin-bottom: 15px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      color: #e0e0e0;
      text-shadow: none;
    }
    .ai-chat-section .section-title i {
      color: #FFB26B;
    }

    .chat-messages {
      flex-grow: 1;
      overflow-y: auto;
      padding-right: 10px; /* For scrollbar space */
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    /* Hide scrollbar for chat messages */
    .chat-messages::-webkit-scrollbar {
      width: 8px;
    }
    .chat-messages::-webkit-scrollbar-track {
      background: #3f3f5a;
      border-radius: 10px;
    }
    .chat-messages::-webkit-scrollbar-thumb {
      background: #5a5a7a;
      border-radius: 10px;
    }

    .chat-message {
      padding: 10px 15px;
      border-radius: 15px;
      max-width: 85%;
      word-wrap: break-word;
      font-size: 0.95em;
    }
    .user-message {
      background-color: #0f3460; /* Darker blue */
      align-self: flex-end;
      border-bottom-right-radius: 5px;
    }
    .bot-message {
      background-color: #4B0082; /* Darker purple */
      align-self: flex-start;
      border-bottom-left-radius: 5px;
    }

    .chat-input-area {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    .chat-input-area input {
      flex-grow: 1;
      padding: 10px 15px;
      border-radius: 20px;
      border: 1px solid #4a4a6e;
      background-color: #3f3f5a;
      color: #e0e0e0;
      font-size: 1em;
    }
    .chat-input-area input::placeholder {
      color: #999;
    }
    .chat-input-area input:focus {
      outline: none;
      border-color: #FFB26B;
      box-shadow: 0 0 8px rgba(255, 178, 107, 0.4);
    }
    .chat-input-area button {
      background: linear-gradient(90deg, #FF7B54, #FFB26B); /* Orange gradient */
      border: none;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      color: white;
      font-size: 1.2em;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .chat-input-area button:hover {
      box-shadow: 0 0 15px rgba(255, 123, 84, 0.5);
      transform: scale(1.05);
    }

    /* Section 3: Music Player */
    .music-player-section {
      grid-area: 2 / 1 / 3 / 2; /* Row 2, Column 1 */
      justify-content: space-between;
      align-items: center;
      padding: 20px;
    }
    .music-player-section .section-title {
      font-size: 1.5em;
      margin-bottom: 20px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      color: #e0e0e0;
      text-shadow: none;
    }
    .music-player-section .section-title i {
      color: #8BC34A; /* Green for music */
    }

    .current-track-info {
      font-size: 1.1em;
      margin-bottom: 15px;
      text-align: center;
      color: #ccc;
    }
    #current-track-title {
      font-weight: 600;
      color: #FFB26B;
    }

    .music-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      margin-bottom: 20px;
    }
    .music-controls .control-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      font-size: 1.3em;
      background-color: #0f3460;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }
    .music-controls .control-btn:hover {
      background-color: #16213e;
      transform: scale(1.05);
    }
    .music-controls .control-btn#play-pause-music-btn {
      width: 60px;
      height: 60px;
      font-size: 1.8em;
      background: linear-gradient(90deg, #8A2BE2, #4B0082);
    }
    .music-controls .control-btn#play-pause-music-btn:hover {
      box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
    }

    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-grow: 1;
      max-width: 200px;
    }
    .volume-control i {
      font-size: 1.2em;
      color: #aaa;
    }
    #volume-slider {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      background: #4a4a6e;
      border-radius: 5px;
      outline: none;
      transition: opacity .2s;
    }
    #volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #FFB26B;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(255, 178, 107, 0.7);
    }
    #volume-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #FFB26B;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(255, 178, 107, 0.7);
    }

    .music-playlist {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-top: 15px;
    }
    .playlist-item {
      background-color: #3f3f5a;
      color: #e0e0e0;
      border: 1px solid #4a4a6e;
      padding: 8px 15px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.9em;
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }
    .playlist-item:hover {
      background-color: #4a4a6e;
      border-color: #FFB26B;
    }
    .playlist-item.active {
      background: linear-gradient(90deg, #FF7B54, #FFB26B);
      border-color: #FF7B54;
      font-weight: 600;
    }


    /* Section 4: Pomodoro Timer */
    .pomodoro-section {
      grid-area: 2 / 2 / 3 / 3; /* Row 2, Column 2 */
      justify-content: space-between;
      align-items: center;
      padding: 20px;
    }
    .pomodoro-section .section-title {
      font-size: 1.5em;
      margin-bottom: 20px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      color: #e0e0e0;
      text-shadow: none;
    }
    .pomodoro-section .section-title i {
      color: #6366F1; /* Blue for pomodoro */
    }

    .timer-display {
      font-family: 'Inter', sans-serif; /* Using Inter for numbers */
      font-size: 4em;
      font-weight: 700;
      color: #FFB26B;
      text-shadow: 0 0 10px rgba(255, 178, 107, 0.5);
      margin-bottom: 20px;
      background-color: #1a1a2e;
      padding: 15px 30px;
      border-radius: 10px;
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
    }

    .timer-presets {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    .timer-preset-btn {
      background-color: #0f3460;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.3s ease;
    }
    .timer-preset-btn:hover {
      background-color: #16213e;
    }
    .timer-preset-btn.active {
      background: linear-gradient(90deg, #6366F1, #8B5CF6); /* Blue gradient */
      font-weight: 600;
    }

    .timer-action-buttons {
      display: flex;
      justify-content: center;
      gap: 15px;
    }
    .timer-action-buttons .control-btn {
      background-color: #8BC34A; /* Green for start */
    }
    .timer-action-buttons .control-btn:hover {
      background-color: #7cb342;
    }
    .timer-action-buttons .control-btn#pause-pomodoro-btn {
      background-color: #f0ad4e; /* Orange for pause */
    }
    .timer-action-buttons .control-btn#pause-pomodoro-btn:hover {
      background-color: #ec971f;
    }
    .timer-action-buttons .control-btn#reset-pomodoro-btn {
      background-color: #5bc0de; /* Blue for reset */
    }
    .timer-action-buttons .control-btn#reset-pomodoro-btn:hover {
      background-color: #46b8da;
    }


    /* Responsive Adjustments */
    @media (max-width: 1024px) {
      #viberoom-container {
        height: auto;
        min-height: 95vh;
      }
      .main-room-grid {
        grid-template-columns: 1fr; /* Stack sections vertically */
        grid-template-rows: auto auto auto auto; /* Each section gets a row */
      }
      .video-feeds-section {
        grid-area: auto; /* Reset grid area */
      }
      .ai-chat-section {
        grid-area: auto;
      }
      .music-player-section {
        grid-area: auto;
      }
      .pomodoro-section {
        grid-area: auto;
      }

      .video-feeds-section[data-participants="1"],
      .video-feeds-section[data-participants="2"],
      .video-feeds-section[data-participants="3"],
      .video-feeds-section[data-participants="4"] {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Adjust min width for smaller screens */
        grid-auto-rows: minmax(150px, 1fr);
      }

      .section-title {
        font-size: 2em;
      }
      .ai-chat-section .section-title,
      .music-player-section .section-title,
      .pomodoro-section .section-title {
        font-size: 1.3em;
      }
      .timer-display {
        font-size: 3em;
      }
    }

    @media (max-width: 768px) {
      #viberoom-container {
        border-radius: 0;
        width: 100%;
        height: 100vh;
      }
      body {
        padding: 0;
      }
      .options-grid {
        grid-template-columns: 1fr; /* Stack room options */
      }
      .option-btn {
        font-size: 1.2em;
        padding: 20px 15px;
      }
      .option-btn i {
        font-size: 2em;
      }
      .modal-content {
        padding: 20px;
      }
      .modal-title {
        font-size: 1.8em;
      }
      .modal-section h4 {
        font-size: 1.1em;
      }
      .modal-content input, .modal-content select, .action-btn {
        padding: 10px;
        font-size: 1em;
      }
      .top-bar {
        flex-direction: column;
        gap: 10px;
        padding: 10px;
      }
      .top-bar h3 {
        font-size: 1em;
      }
      .top-bar-actions {
        width: 100%;
        justify-content: center;
      }
      .control-btn {
        padding: 6px 12px;
        font-size: 0.9em;
      }
      .main-room-grid {
        padding: 10px;
        gap: 10px;
      }
      .video-feeds-section, .ai-chat-section, .music-player-section, .pomodoro-section {
        padding: 10px;
      }
      .video-feeds-section[data-participants="1"],
      .video-feeds-section[data-participants="2"],
      .video-feeds-section[data-participants="3"],
      .video-feeds-section[data-participants="4"] {
        grid-template-columns: 1fr; /* Stack videos on very small screens */
        grid-auto-rows: minmax(120px, 1fr);
      }
      .video-overlay {
        opacity: 1; /* Always show controls on small screens for easier interaction */
        pointer-events: auto;
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
        padding: 8px;
      }
      .video-controls-overlay {
        width: 100%;
        justify-content: flex-end;
      }
      .video-control-btn {
        width: 30px;
        height: 30px;
        font-size: 0.8em;
      }
      .chat-message {
        padding: 8px 12px;
        font-size: 0.9em;
      }
      .chat-input-area input {
        padding: 8px 12px;
        font-size: 0.9em;
      }
      .chat-input-area button {
        width: 40px;
        height: 40px;
        font-size: 1em;
      }
      .music-controls .control-btn {
        width: 40px;
        height: 40px;
        font-size: 1em;
      }
      .music-controls .control-btn#play-pause-music-btn {
        width: 50px;
        height: 50px;
        font-size: 1.5em;
      }
      .timer-display {
        font-size: 2.5em;
      }
      .timer-preset-btn {
        padding: 8px 15px;
        font-size: 0.9em;
      }
    }

    @media (max-width: 480px) {
      .section-title {
        font-size: 1.8em;
      }
      .option-btn {
        font-size: 1.1em;
      }
      .modal-content {
        padding: 15px;
      }
      .modal-title {
        font-size: 1.5em;
      }
      .timer-display {
        font-size: 2em;
      }
      .music-playlist {
        flex-direction: column;
        align-items: center;
      }
      .playlist-item {
        width: 90%;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <div id="loading-screen" class="hidden">
    <div class="loading-text">Vibing...</div>
  </div>

  <div id="viberoom-container">
    <div id="room-options-screen" class="visible screen">
      <h2 class="section-title">Choose Your Vibe</h2>
      <div class="options-grid">
        <button id="private-room-btn" class="option-btn">
          <i class="fas fa-lock"></i> Private Room
        </button>
        <button id="selective-room-btn" class="option-btn coming-soon">
          <i class="fas fa-users"></i> Selective Room
          <span class="coming-soon-badge">Coming Soon</span>
        </button>
        <button id="random-room-btn" class="option-btn coming-soon">
          <i class="fas fa-random"></i> Random Room
          <span class="coming-soon-badge">Coming Soon</span>
        </button>
        <button id="join-room-btn" class="option-btn">
          <i class="fas fa-door-open"></i> Join Room
        </button>
      </div>
    </div>

    <div id="private-room-modal" class="hidden modal">
      <div class="modal-content">
        <span class="close-button">&times;</span>
        <h3 class="modal-title">Private Room</h3>

        <div class="modal-section">
          <h4>Create New Room</h4>
          <label for="num-persons">Max Persons (1-4):</label>
          <input type="number" id="num-persons" value="4" min="1" max="4">

          <label for="category-select">Category:</label>
          <select id="category-select">
            <option value="study" selected>Study</option>
            <option value="music">Music</option>
            <option value="gym">Gym</option>
            <option value="random">Random</option>
          </select>
          <button id="create-private-room-btn" class="action-btn">Create Room</button>
        </div>

        <div class="modal-section">
          <h4>Join Existing Room</h4>
          <input type="text" id="join-room-id" placeholder="Room ID">
          <input type="password" id="join-room-pass" placeholder="Password">
          <button id="join-private-room-btn" class="action-btn">Join Room</button>
        </div>
      </div>
    </div>

    <div id="video-room-screen" class="hidden screen">
      <div class="rgb-glow-border"></div>

      <div class="top-bar">
        <h3 id="room-info">Room ID: <span id="current-room-id"></span> | User ID: <span id="current-user-id"></span></h3>
        <div class="top-bar-actions">
          <button id="exit-room-btn" class="control-btn exit-btn"><i class="fas fa-sign-out-alt"></i> Exit Room</button>
          <button id="end-room-btn" class="control-btn end-btn hidden"><i class="fas fa-times-circle"></i> End Room</button>
        </div>
      </div>

      <div class="main-room-grid">
        <div class="video-feeds-section" id="video-feeds-section">
          <div class="video-wrapper" id="local-video-wrapper">
            <video id="local-video" autoplay muted></video>
            <div class="video-overlay">
              <span class="video-username">You</span>
              <div class="video-controls-overlay">
                <button class="video-control-btn" id="local-cam-toggle"><i class="fas fa-video"></i></button>
                <button class="video-control-btn" id="local-mic-toggle"><i class="fas fa-microphone"></i></button>
              </div>
            </div>
          </div>
          </div>

        <div class="ai-chat-section">
          <h3 class="section-title"><i class="fas fa-robot"></i> Gemini AI Chat</h3>
          <div class="chat-messages" id="gemini-chat-messages">
            <div class="chat-message bot-message">
              <p>Hello! I'm Gemini. How can I assist you with your study session today?</p>
            </div>
          </div>
          <div class="chat-input-area">
            <input type="text" id="gemini-chat-input" placeholder="Ask Gemini a question...">
            <button id="send-gemini-chat-btn"><i class="fas fa-paper-plane"></i></button>
          </div>
        </div>

        <div class="music-player-section">
          <h3 class="section-title"><i class="fas fa-music"></i> Music Vibe</h3>
          <audio id="audio-player" loop></audio>
          <div class="current-track-info">
            Now Playing: <span id="current-track-title">No music selected</span>
          </div>
          <div class="music-controls">
            <button id="prev-music-btn" class="control-btn"><i class="fas fa-backward"></i></button>
            <button id="play-pause-music-btn" class="control-btn"><i class="fas fa-play"></i></button>
            <button id="next-music-btn" class="control-btn"><i class="fas fa-forward"></i></button>
            <div class="volume-control">
              <i class="fas fa-volume-down"></i>
              <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5">
              <i class="fas fa-volume-up"></i>
            </div>
          </div>
          <div class="music-playlist">
            <button class="playlist-item" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" data-title="Relaxing Study Beat 1">Relaxing Study Beat 1</button>
            <button class="playlist-item" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3" data-title="Focus Flow 2">Focus Flow 2</button>
            <button class="playlist-item" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3" data-title="Chillout Session 3">Chillout Session 3</button>
          </div>
        </div>

        <div class="pomodoro-section">
          <h3 class="section-title"><i class="fas fa-clock"></i> Pomodoro Timer</h3>
          <div class="timer-display" id="pomodoro-timer-display">25:00</div>
          <div class="timer-presets">
            <button class="timer-preset-btn" data-time="25">25 min</button>
            <button class="timer-preset-btn" data-time="45">45 min</button>
            <button class="timer-preset-btn" data-time="60">1 hr</button>
            <button class="timer-preset-btn" data-time="90">1.5 hr</button>
          </div>
          <div class="timer-action-buttons">
            <button id="start-pomodoro-btn" class="control-btn"><i class="fas fa-play"></i> Start</button>
            <button id="pause-pomodoro-btn" class="control-btn hidden"><i class="fas fa-pause"></i> Pause</button>
            <button id="reset-pomodoro-btn" class="control-btn hidden"><i class="fas fa-redo"></i> Reset</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="customAlertModal" class="custom-modal">
    <div class="custom-modal-content">
      <h3 id="modalMessage"></h3>
      <button id="modalCloseButton">OK</button>
    </div>
  </div>

  <div id="confirmation-modal" class="hidden modal">
    <div class="modal-content">
      <p id="confirmation-message"></p>
      <div class="modal-buttons">
        <button id="confirm-yes-btn" class="action-btn">Yes</button>
        <button id="confirm-no-btn" class="action-btn cancel-btn">No</button>
      </div>
    </div>
  </div>

  <script type="module">
    // viberoom.js - Integrated JavaScript Logic

    // Import Firebase modules
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js';
    import { getAuth, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.13.2/firebase-auth.js';
    import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, collection, query, where, getDocs, deleteDoc } from 'https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js';
    import { getDatabase, ref, set, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.13.2/firebase-database.js';

    // --- Firebase Configuration (Ensure this matches your login-profile.html config) ---
    // IMPORTANT: Replace with your actual Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyC1Si1eckeNa-aF2RtQzIDckDhbvZlI66A", // Your Firebase API Key from credentials.txt
      authDomain: "viberoom-3af1f.firebaseapp.com",
      projectId: "viberoom-3af1f",
      storageBucket: "viberoom-3af1f.firebasestorage.app",
      messagingSenderId: "84466588442",
      appId: "1:84466588442:web:b2100ca39f2b25dba36aa3"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const rtdb = getDatabase(app); // Realtime Database for presence (optional, but good for real-time status)

    // --- UI Elements ---
    const loadingScreen = document.getElementById('loading-screen');
    const customAlertModal = document.getElementById('customAlertModal');
    const modalMessage = document.getElementById('modalMessage');
    const modalCloseButton = document.getElementById('modalCloseButton');
    const confirmationModal = document.getElementById('confirmation-modal');
    const confirmationMessage = document.getElementById('confirmation-message');
    const confirmYesBtn = document.getElementById('confirm-yes-btn');
    const confirmNoBtn = document.getElementById('confirm-no-btn');

    const roomOptionsScreen = document.getElementById('room-options-screen');
    const privateRoomBtn = document.getElementById('private-room-btn');
    const selectiveRoomBtn = document.getElementById('selective-room-btn');
    const randomRoomBtn = document.getElementById('random-room-btn');
    const joinRoomBtn = document.getElementById('join-room-btn');

    const privateRoomModal = document.getElementById('private-room-modal');
    const privateRoomModalCloseBtn = privateRoomModal.querySelector('.close-button');
    const numPersonsInput = document.getElementById('num-persons');
    const categorySelect = document.getElementById('category-select');
    const createPrivateRoomBtn = document.getElementById('create-private-room-btn');
    const joinRoomIdInput = document.getElementById('join-room-id');
    const joinRoomPassInput = document.getElementById('join-room-pass');
    const joinPrivateRoomBtn = document.getElementById('join-private-room-btn');

    const videoRoomScreen = document.getElementById('video-room-screen');
    const currentRoomIdDisplay = document.getElementById('current-room-id');
    const currentUserIdDisplay = document.getElementById('current-user-id');
    const exitRoomBtn = document.getElementById('exit-room-btn');
    const endRoomBtn = document.getElementById('end-room-btn');

    const videoFeedsSection = document.getElementById('video-feeds-section');
    const localVideo = document.getElementById('local-video');
    const localCamToggle = document.getElementById('local-cam-toggle');
    const localMicToggle = document.getElementById('local-mic-toggle');

    const geminiChatMessages = document.getElementById('gemini-chat-messages');
    const geminiChatInput = document.getElementById('gemini-chat-input');
    const sendGeminiChatBtn = document.getElementById('send-gemini-chat-btn');

    const audioPlayer = document.getElementById('audio-player');
    const currentTrackTitle = document.getElementById('current-track-title');
    const prevMusicBtn = document.getElementById('prev-music-btn');
    const playPauseMusicBtn = document.getElementById('play-pause-music-btn');
    const nextMusicBtn = document.getElementById('next-music-btn');
    const volumeSlider = document.getElementById('volume-slider');
    const playlistItems = document.querySelectorAll('.playlist-item');

    const pomodoroTimerDisplay = document.getElementById('pomodoro-timer-display');
    const timerPresetBtns = document.querySelectorAll('.timer-preset-btn');
    const startPomodoroBtn = document.getElementById('start-pomodoro-btn');
    const pausePomodoroBtn = document.getElementById('pause-pomodoro-btn');
    const resetPomodoroBtn = document.getElementById('reset-pomodoro-btn');

    // --- Global Variables ---
    let localStream; // To hold the user's camera and microphone stream
    let currentRoom = null; // Stores details of the active room
    let isRoomCreator = false;
    let pomodoroInterval;
    let pomodoroTimeLeft;
    let isPomodoroRunning = false;
    let currentMusicIndex = 0;

    // Predefined music tracks (replace with your own public domain or licensed URLs)
    const musicTracks = [
      { title: "Relaxing Study Beat 1", src: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" },
      { title: "Focus Flow 2", src: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3" },
      { title: "Chillout Session 3", src: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3" },
      // Add more tracks as needed
    ];

    // --- Utility Functions ---

    /**
     * Displays a custom alert modal with a given message.
     * @param {string} message - The message to display in the modal.
     */
    function showCustomAlert(message) {
      modalMessage.textContent = message;
      customAlertModal.classList.add('visible');
      customAlertModal.classList.remove('hidden');
    }

    // Close button for custom alert modal
    modalCloseButton.addEventListener('click', () => {
      customAlertModal.classList.add('hidden');
      customAlertModal.classList.remove('visible');
    });

    /**
     * Shows the loading screen.
     */
    function showLoadingScreen() {
      loadingScreen.classList.remove('hidden');
      loadingScreen.classList.add('visible');
    }

    /**
     * Hides the loading screen.
     */
    function hideLoadingScreen() {
      loadingScreen.classList.add('hidden');
      loadingScreen.classList.remove('visible');
    }

    /**
     * Shows a confirmation modal.
     * @param {string} message - The confirmation message.
     * @returns {Promise<boolean>} - Resolves true if confirmed, false if cancelled.
     */
    function showConfirmationModal(message) {
      return new Promise((resolve) => {
        confirmationMessage.textContent = message;
        confirmationModal.classList.remove('hidden');
        confirmationModal.classList.add('visible');

        const handleConfirm = () => {
          confirmationModal.classList.add('hidden');
          confirmationModal.classList.remove('visible');
          confirmYesBtn.removeEventListener('click', handleConfirm);
          confirmNoBtn.removeEventListener('click', handleCancel);
          resolve(true);
        };

        const handleCancel = () => {
          confirmationModal.classList.add('hidden');
          confirmationModal.classList.remove('visible');
          confirmYesBtn.removeEventListener('click', handleConfirm);
          confirmNoBtn.removeEventListener('click', handleCancel);
          resolve(false);
        };

        confirmYesBtn.addEventListener('click', handleConfirm);
        confirmNoBtn.addEventListener('click', handleCancel);
      });
    }

    /**
     * Displays a specific screen and hides others.
     * @param {HTMLElement} screenToShow - The screen element to display.
     */
    function showScreen(screenToShow) {
      const allScreens = document.querySelectorAll('.screen');
      allScreens.forEach(screen => {
        if (screen === screenToShow) {
          screen.classList.remove('hidden');
          screen.classList.add('visible');
        } else {
          screen.classList.remove('visible');
          screen.classList.add('hidden');
        }
      });
    }

    /**
     * Generates a random alphanumeric string for Room ID/Password.
     * @param {number} length - The desired length of the string.
     * @returns {string} - The generated random string.
     */
    function generateRandomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    /**
     * Sets user presence in Realtime Database (for real-time status) and updates Firestore status.
     * @param {string} userId - The UID of the user.
     * @param {boolean} isOnline - True if online, false if offline.
     */
    async function setUserOnlineStatus(userId, isOnline) {
      const userStatusRTDBRef = ref(rtdb, 'presence/' + userId);
      const userDocRef = doc(db, 'users', userId);

      if (isOnline) {
        // Set up onDisconnect to set status to offline when client disconnects
        onDisconnect(userStatusRTDBRef).set(false).then(() => {
          set(userStatusRTDBRef, true); // Set user's current status to true
        }).catch(error => {
          console.error("Error setting onDisconnect or initial RTDB presence:", error);
        });

        // Update Firestore for display purposes
        try {
          await updateDoc(userDocRef, { status: 'Online' });
        } catch (e) {
          console.error("Error updating Firestore status to online:", e);
        }
      } else {
        // If logging out explicitly, cancel onDisconnect and set offline immediately
        onDisconnect(userStatusRTDBRef).cancel();
        set(userStatusRTDBRef, false);
        try {
          await updateDoc(userDocRef, { status: 'Offline' });
        } catch (e) {
          console.error("Error updating Firestore status to offline:", e);
        }
      }
    }

    // --- Firebase Auth State Listener ---
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        // User is signed in.
        console.log("User signed in:", user.uid);
        // You might want to redirect to viberoom.html from login-profile.html
        // For this example, we assume viberoom.html is the landing page after login.
        showScreen(roomOptionsScreen); // Show room options if user is logged in
        currentUserIdDisplay.textContent = user.uid; // Display user ID

        // Set user online status
        await setUserOnlineStatus(user.uid, true);

        // Optional: Listen for changes in the user's Firestore document for status updates if needed
        // const userDocRef = doc(db, 'users', user.uid);
        // onSnapshot(userDocRef, (docSnap) => {
        //   if (docSnap.exists()) {
        //     const profile = docSnap.data();
        //     // Update UI with status if necessary, e.g., in a profile section
        //   }
        // }, (error) => {
        //   console.error("Error listening to Firestore status changes:", error);
        // });

      } else {
        // User is signed out.
        console.log("User signed out.");
        // Redirect to login page if not authenticated
        // window.location.href = 'login-profile.html';
        showCustomAlert("You need to be logged in to access VibeRoom.");
        // For now, just show the room options screen but disable actions
        showScreen(roomOptionsScreen);
        // Disable buttons or show a message to log in
      }
    });

    // --- Room Options Functionality ---
    privateRoomBtn.addEventListener('click', () => {
      if (!auth.currentUser) {
        showCustomAlert("Please log in to create or join a room.");
        return;
      }
      privateRoomModal.classList.remove('hidden');
      privateRoomModal.classList.add('visible');
    });

    selectiveRoomBtn.addEventListener('click', () => {
      showCustomAlert("Selective Room is coming soon!");
    });

    randomRoomBtn.addEventListener('click', () => {
      showCustomAlert("Random Room is coming soon!");
    });

    joinRoomBtn.addEventListener('click', () => {
      if (!auth.currentUser) {
        showCustomAlert("Please log in to create or join a room.");
        return;
      }
      privateRoomModal.classList.remove('hidden');
      privateRoomModal.classList.add('visible');
      // Pre-fill join section or highlight it if desired
    });

    privateRoomModalCloseBtn.addEventListener('click', () => {
      privateRoomModal.classList.add('hidden');
      privateRoomModal.classList.remove('visible');
    });

    // --- Private Room Creation ---
    createPrivateRoomBtn.addEventListener('click', async () => {
      const user = auth.currentUser;
      if (!user) {
        showCustomAlert("You must be logged in to create a room.");
        return;
      }

      const maxPersons = parseInt(numPersonsInput.value);
      const category = categorySelect.value;

      if (category !== 'study') {
        showCustomAlert(`${category} category is coming soon! Please select 'Study'.`);
        return;
      }

      showLoadingScreen();
      try {
        // Request camera and mic permissions
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

        // Generate Room ID and Password
        const roomId = generateRandomString(8);
        const roomPass = generateRandomString(6); // Simple password

        // Store room details in Firestore
        const roomRef = doc(db, 'rooms', roomId);
        await setDoc(roomRef, {
          creatorId: user.uid,
          maxPersons: maxPersons,
          category: category,
          password: roomPass,
          createdAt: new Date(),
          participants: [{
            uid: user.uid,
            username: user.displayName || user.email.split('@')[0],
            isCameraOn: true,
            isMicOn: true,
            isCreator: true
          }]
        });

        currentRoom = { id: roomId, password: roomPass, creatorId: user.uid };
        isRoomCreator = true;

        hideLoadingScreen();
        showCustomAlert(`Room Created!\nID: ${roomId}\nPassword: ${roomPass}\nShare this with your friends!`);

        // Transition to video room screen
        privateRoomModal.classList.add('hidden');
        privateRoomModal.classList.remove('visible');
        await enterVideoRoom(user.uid, roomId);

      } catch (error) {
        hideLoadingScreen();
        console.error("Error creating room or getting media:", error);
        if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
          showCustomAlert("Camera and microphone access denied. Please allow permissions to use VibeRoom.");
        } else if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
          showCustomAlert("No camera or microphone found. Please ensure devices are connected.");
        } else {
          showCustomAlert("Failed to create room: " + error.message);
        }
      }
    });

    // --- Private Room Joining ---
    joinPrivateRoomBtn.addEventListener('click', async () => {
      const user = auth.currentUser;
      if (!user) {
        showCustomAlert("You must be logged in to join a room.");
        return;
      }

      const roomId = joinRoomIdInput.value.trim();
      const roomPass = joinRoomPassInput.value.trim();

      if (!roomId || !roomPass) {
        showCustomAlert("Please enter both Room ID and Password.");
        return;
      }

      showLoadingScreen();
      try {
        const roomRef = doc(db, 'rooms', roomId);
        const roomDoc = await getDoc(roomRef);

        if (!roomDoc.exists()) {
          hideLoadingScreen();
          showCustomAlert("Room not found. Please check the ID.");
          return;
        }

        const roomData = roomDoc.data();
        if (roomData.password !== roomPass) {
          hideLoadingScreen();
          showCustomAlert("Incorrect room password.");
          return;
        }

        if (roomData.participants.length >= roomData.maxPersons) {
          hideLoadingScreen();
          showCustomAlert("Room is full.");
          return;
        }

        // Check if user is already a participant
        const isAlreadyParticipant = roomData.participants.some(p => p.uid === user.uid);
        if (isAlreadyParticipant) {
            showCustomAlert("You are already in this room.");
            hideLoadingScreen();
            privateRoomModal.classList.add('hidden');
            privateRoomModal.classList.remove('visible');
            await enterVideoRoom(user.uid, roomId);
            return;
        }

        // Request camera and mic permissions
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

        // Add user to participants array in Firestore
        const newParticipant = {
          uid: user.uid,
          username: user.displayName || user.email.split('@')[0],
          isCameraOn: true,
          isMicOn: true,
          isCreator: false
        };
        await updateDoc(roomRef, {
          participants: [...roomData.participants, newParticipant]
        });

        currentRoom = { id: roomId, password: roomPass, creatorId: roomData.creatorId };
        isRoomCreator = false;

        hideLoadingScreen();
        showCustomAlert("Successfully joined the room!");

        // Transition to video room screen
        privateRoomModal.classList.add('hidden');
        privateRoomModal.classList.remove('visible');
        await enterVideoRoom(user.uid, roomId);

      } catch (error) {
        hideLoadingScreen();
        console.error("Error joining room or getting media:", error);
        if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
          showCustomAlert("Camera and microphone access denied. Please allow permissions to use VibeRoom.");
        } else if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
          showCustomAlert("No camera or microphone found. Please ensure devices are connected.");
        } else {
          showCustomAlert("Failed to join room: " + error.message);
        }
      }
    });

    // --- Video Room Functionality ---

    /**
     * Enters the video room, sets up local stream, and listens for remote participants.
     * @param {string} userId - The current user's ID.
     * @param {string} roomId - The ID of the room.
     */
    async function enterVideoRoom(userId, roomId) {
      showScreen(videoRoomScreen);
      currentRoomIdDisplay.textContent = roomId;
      currentUserIdDisplay.textContent = userId;

      // Display End Room button only for the creator
      if (isRoomCreator) {
        endRoomBtn.classList.remove('hidden');
      } else {
        endRoomBtn.classList.add('hidden');
      }

      // Set local video stream
      if (localStream) {
        localVideo.srcObject = localStream;
        localCamToggle.classList.add('active'); // Assume cam is on initially
        localMicToggle.classList.add('active'); // Assume mic is on initially
      }

      // Listen for real-time updates to participants in Firestore
      const roomRef = doc(db, 'rooms', roomId);
      onSnapshot(roomRef, (docSnap) => {
        if (docSnap.exists()) {
          const roomData = docSnap.data();
          const participants = roomData.participants || [];
          updateVideoFeeds(userId, participants);

          // If room creator leaves/ends the room, all participants should be exited
          if (roomData.status === 'ended' && !isRoomCreator) {
            showCustomAlert("The room has been ended by the creator.");
            exitRoom(false); // Exit without confirmation
          }
        } else {
          // Room no longer exists (e.g., creator ended it)
          if (currentRoom && currentRoom.id === roomId) { // Only if this was the current room
            showCustomAlert("The room you were in no longer exists.");
            exitRoom(false); // Exit without confirmation
          }
        }
      }, (error) => {
        console.error("Error listening to room participants:", error);
        showCustomAlert("Lost connection to room updates. Please try rejoining.");
        exitRoom(false); // Force exit on error
      });

      // --- WebRTC Placeholder for Peer Connections ---
      // In a real application, you would initialize RTCPeerConnection here for each remote participant
      // and set up signaling to exchange offers, answers, and ICE candidates.
      // This is a complex part that requires a backend signaling server.

      // Example: Placeholder for peer connections (not functional for multi-user without signaling)
      // let peerConnections = {}; // Map of userId to RTCPeerConnection

      // function createPeerConnection(remoteUserId) {
      //   const peerConnection = new RTCPeerConnection({
      //     iceServers: [
      //       { urls: 'stun:stun.l.google.com:19302' }, // Google's public STUN server
      //       // Add your TURN server here for robust connectivity
      //       // { urls: 'turn:YOUR_TURN_SERVER_URL', username: 'YOUR_USERNAME', credential: 'YOUR_PASSWORD' }
      //     ]
      //   });

      //   localStream.getTracks().forEach(track => {
      //     peerConnection.addTrack(track, localStream);
      //   });

      //   peerConnection.ontrack = (event) => {
      //     // When a remote stream track is received, add it to the corresponding video element
      //     const remoteVideoElement = document.getElementById(`video-${remoteUserId}`);
      //     if (remoteVideoElement) {
      //       if (remoteVideoElement.srcObject !== event.streams[0]) {
      //         remoteVideoElement.srcObject = event.streams[0];
      //       }
      //     }
      //   };

      //   peerConnection.onicecandidate = (event) => {
      //     if (event.candidate) {
      //       // Send ICE candidate to remote peer via signaling server
      //       // signalingServer.sendIceCandidate(remoteUserId, event.candidate);
      //     }
      //   };

      //   peerConnection.onnegotiationneeded = async () => {
      //     try {
      //       const offer = await peerConnection.createOffer();
      //       await peerConnection.setLocalDescription(offer);
      //       // Send offer to remote peer via signaling server
      //       // signalingServer.sendOffer(remoteUserId, peerConnection.localDescription);
      //     } catch (e) {
      //       console.error('Error creating offer:', e);
      //     }
      //   };

      //   peerConnections[remoteUserId] = peerConnection;
      //   return peerConnection;
      // }

      // This `updateVideoFeeds` function will dynamically add/remove video elements.
      // The actual WebRTC connections for remote peers would be managed based on these participants.
    }

    /**
     * Dynamically updates the video feed sections based on current participants.
     * @param {string} currentUserId - The ID of the current logged-in user.
     * @param {Array<Object>} participants - Array of participant objects from Firestore.
     */
    function updateVideoFeeds(currentUserId, participants) {
      // Clear existing remote video wrappers
      const existingRemoteWrappers = videoFeedsSection.querySelectorAll('.video-wrapper:not(#local-video-wrapper)');
      existingRemoteWrappers.forEach(wrapper => wrapper.remove());

      // Set data-participants attribute for CSS grid adjustments
      videoFeedsSection.setAttribute('data-participants', participants.length);

      participants.forEach(p => {
        if (p.uid === currentUserId) {
          // Update local user's video controls
          localCamToggle.classList.toggle('active', p.isCameraOn);
          localMicToggle.classList.toggle('active', p.isMicOn);
          localCamToggle.innerHTML = p.isCameraOn ? '<i class="fas fa-video"></i>' : '<i class="fas fa-video-slash"></i>';
          localMicToggle.innerHTML = p.isMicOn ? '<i class="fas fa-microphone"></i>' : '<i class="fas fa-microphone-slash"></i>';
          localVideo.muted = true; // Always mute local video for self-view
          if (localStream) {
            localStream.getVideoTracks().forEach(track => track.enabled = p.isCameraOn);
            localStream.getAudioTracks().forEach(track => track.enabled = p.isMicOn);
          }
        } else {
          // Add or update remote participant's video feed
          let remoteVideoWrapper = document.getElementById(`video-wrapper-${p.uid}`);
          if (!remoteVideoWrapper) {
            remoteVideoWrapper = document.createElement('div');
            remoteVideoWrapper.id = `video-wrapper-${p.uid}`;
            remoteVideoWrapper.classList.add('video-wrapper');
            remoteVideoWrapper.innerHTML = `
              <video id="video-${p.uid}" autoplay></video>
              <div class="video-overlay">
                <span class="video-username">${p.username}</span>
                <div class="video-controls-overlay">
                  <button class="video-control-btn remote-cam-toggle" data-uid="${p.uid}"><i class="fas fa-video"></i></button>
                  <button class="video-control-btn remote-mic-toggle" data-uid="${p.uid}"><i class="fas fa-microphone"></i></button>
                </div>
              </div>
            `;
            videoFeedsSection.appendChild(remoteVideoWrapper);

            // Add event listeners for remote controls
            const remoteCamToggle = remoteVideoWrapper.querySelector('.remote-cam-toggle');
            const remoteMicToggle = remoteVideoWrapper.querySelector('.remote-mic-toggle');

            remoteCamToggle.addEventListener('click', () => toggleRemoteMedia(p.uid, 'camera'));
            remoteMicToggle.addEventListener('click', () => toggleRemoteMedia(p.uid, 'microphone'));
          }

          // Update remote video controls based on participant data
          const remoteCamToggle = remoteVideoWrapper.querySelector('.remote-cam-toggle');
          const remoteMicToggle = remoteVideoWrapper.querySelector('.remote-mic-toggle');
          const remoteVideoElement = remoteVideoWrapper.querySelector('video');

          remoteCamToggle.classList.toggle('active', p.isCameraOn);
          remoteMicToggle.classList.toggle('active', p.isMicOn);
          remoteCamToggle.innerHTML = p.isCameraOn ? '<i class="fas fa-video"></i>' : '<i class="fas fa-video-slash"></i>';
          remoteMicToggle.innerHTML = p.isMicOn ? '<i class="fas fa-microphone"></i>' : '<i class="fas fa-microphone-slash"></i>';

          // Mute/unmute remote video based on isMicOn status (if it were a real stream)
          // For actual WebRTC, you'd control the remote track's `enabled` property.
          // remoteVideoElement.muted = !p.isMicOn; // This would mute the audio for this specific video element

          // Placeholder for setting remote stream (in a real WebRTC app, this would be set by peerConnection.ontrack)
          // if (peerConnections[p.uid] && peerConnections[p.uid].remoteStream) {
          //   remoteVideoElement.srcObject = peerConnections[p.uid].remoteStream;
          // }
        }
      });

      // Remove participants who are no longer in the room
      const currentParticipantUids = participants.map(p => p.uid);
      const allVideoWrappers = videoFeedsSection.querySelectorAll('.video-wrapper');
      allVideoWrappers.forEach(wrapper => {
        const wrapperId = wrapper.id;
        if (wrapperId !== 'local-video-wrapper') {
          const uid = wrapperId.replace('video-wrapper-', '');
          if (!currentParticipantUids.includes(uid)) {
            wrapper.remove();
            // if (peerConnections[uid]) {
            //   peerConnections[uid].close();
            //   delete peerConnections[uid];
            // }
          }
        }
      });
    }

    /**
     * Toggles local camera or microphone.
     * @param {'camera'|'microphone'} type - The type of media to toggle.
     */
    async function toggleLocalMedia(type) {
      if (!localStream) return;

      const user = auth.currentUser;
      if (!user || !currentRoom) return;

      const roomRef = doc(db, 'rooms', currentRoom.id);
      const roomDoc = await getDoc(roomRef);
      if (!roomDoc.exists()) {
        showCustomAlert("Room not found.");
        return;
      }
      const roomData = roomDoc.data();
      let participants = roomData.participants || [];
      let currentUserParticipant = participants.find(p => p.uid === user.uid);

      if (currentUserParticipant) {
        if (type === 'camera') {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            currentUserParticipant.isCameraOn = videoTrack.enabled;
          }
        } else if (type === 'microphone') {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            currentUserParticipant.isMicOn = audioTrack.enabled;
          }
        }
        // Update Firestore to reflect changes
        await updateDoc(roomRef, { participants: participants });
      }
    }

    localCamToggle.addEventListener('click', () => toggleLocalMedia('camera'));
    localMicToggle.addEventListener('click', () => toggleLocalMedia('microphone'));

    /**
     * Placeholder for toggling remote user's camera or microphone.
     * In a real WebRTC app, this would send a signaling message to the remote peer
     * to request them to toggle their media, or locally mute/unmute the *received* stream.
     * For this demo, it will just update the icon locally.
     * @param {string} remoteUid - The UID of the remote user.
     * @param {'camera'|'microphone'} type - The type of media to toggle.
     */
    async function toggleRemoteMedia(remoteUid, type) {
      const user = auth.currentUser;
      if (!user || !currentRoom) return;

      // In a real WebRTC app, you'd send a signaling message like:
      // signalingClient.sendControlMessage(remoteUid, { type: 'toggleMedia', mediaType: type });

      // For this demo, we'll just update the Firestore status for the remote user
      // This would typically be handled by the remote user's client updating their own status.
      // This is a simplification for demonstration purposes.
      const roomRef = doc(db, 'rooms', currentRoom.id);
      const roomDoc = await getDoc(roomRef);
      if (!roomDoc.exists()) {
        showCustomAlert("Room not found.");
        return;
      }
      const roomData = roomDoc.data();
      let participants = roomData.participants || [];
      let remoteUserParticipant = participants.find(p => p.uid === remoteUid);

      if (remoteUserParticipant) {
        if (type === 'camera') {
          remoteUserParticipant.isCameraOn = !remoteUserParticipant.isCameraOn;
        } else if (type === 'microphone') {
          remoteUserParticipant.isMicOn = !remoteUserParticipant.isMicOn;
          // In a real app, you would mute the *received* audio track here:
          // const remoteVideoElement = document.getElementById(`video-${remoteUid}`);
          // if (remoteVideoElement && remoteVideoElement.srcObject) {
          //   remoteVideoElement.srcObject.getAudioTracks().forEach(track => track.enabled = remoteUserParticipant.isMicOn);
          // }
        }
        await updateDoc(roomRef, { participants: participants });
      }
      showCustomAlert(`Toggled ${type} for ${remoteUid}. (Note: This is a local simulation; real control requires signaling.)`);
    }


    /**
     * Exits the current room.
     * @param {boolean} askConfirmation - Whether to ask for user confirmation.
     */
    async function exitRoom(askConfirmation = true) {
      if (askConfirmation) {
        const confirmed = await showConfirmationModal("Are you sure you want to exit the room?");
        if (!confirmed) {
          return;
        }
      }

      const user = auth.currentUser;
      if (user && currentRoom) {
        try {
          const roomRef = doc(db, 'rooms', currentRoom.id);
          const roomDoc = await getDoc(roomRef);
          if (roomDoc.exists()) {
            let participants = roomDoc.data().participants || [];
            participants = participants.filter(p => p.uid !== user.uid);
            await updateDoc(roomRef, { participants: participants });
          }
        } catch (error) {
          console.error("Error removing participant from room:", error);
          showCustomAlert("Failed to update room status on exit. Please try again.");
        }
      }

      // Stop local media tracks
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localVideo.srcObject = null;
      }

      // Close all peer connections (placeholder)
      // for (const uid in peerConnections) {
      //   if (peerConnections[uid]) {
      //     peerConnections[uid].close();
      //     delete peerConnections[uid];
      //   }
      // }

      currentRoom = null;
      isRoomCreator = false;
      resetPomodoro(); // Reset Pomodoro when exiting
      pauseMusic(); // Pause music when exiting

      showScreen(roomOptionsScreen); // Go back to room options
      showCustomAlert("You have exited the room.");
    }

    exitRoomBtn.addEventListener('click', () => exitRoom(true));

    /**
     * Ends the room (only for the creator).
     */
    async function endRoom() {
      const confirmed = await showConfirmationModal("Are you sure you want to end the room for everyone?");
      if (!confirmed) {
        return;
      }

      if (!isRoomCreator || !currentRoom) {
        showCustomAlert("You are not the creator of this room or not in a room.");
        return;
      }

      showLoadingScreen();
      try {
        const roomRef = doc(db, 'rooms', currentRoom.id);
        // Set room status to 'ended' so other participants are notified via onSnapshot
        await updateDoc(roomRef, { status: 'ended' });
        await deleteDoc(roomRef); // Delete the room document

        hideLoadingScreen();
        showCustomAlert("The room has been ended for all participants.");
        exitRoom(false); // Exit locally without further confirmation

      } catch (error) {
        hideLoadingScreen();
        console.error("Error ending room:", error);
        showCustomAlert("Failed to end room: " + error.message);
      }
    }

    endRoomBtn.addEventListener('click', endRoom);


    // --- AI Gemini Chatbox Functionality ---
    /**
     * Adds a message to the Gemini chatbox.
     * @param {string} text - The message text.
     * @param {'user'|'bot'} sender - The sender of the message ('user' or 'bot').
     */
    function addChatMessage(text, sender) {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('chat-message');
      messageDiv.classList.add(sender === 'user' ? 'user-message' : 'bot-message');
      messageDiv.innerHTML = `<p>${text}</p>`;
      geminiChatMessages.appendChild(messageDiv);
      geminiChatMessages.scrollTop = geminiChatMessages.scrollHeight; // Scroll to bottom
    }

    sendGeminiChatBtn.addEventListener('click', () => sendToGemini());
    geminiChatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendToGemini();
      }
    });

    /**
     * Sends a user query to the Gemini AI model.
     */
    async function sendToGemini() {
      const prompt = geminiChatInput.value.trim();
      if (!prompt) {
        showCustomAlert("Please enter a question for Gemini.");
        return;
      }

      addChatMessage(prompt, 'user');
      geminiChatInput.value = ''; // Clear input

      try {
        // API call to Gemini (using gemini-2.0-flash)
        // IMPORTANT: In a production app, this API call should be made from a secure backend (e.g., Firebase Cloud Function)
        // to protect your API key and handle rate limiting.
        let chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };
        const apiKey = ""; // Canvas will automatically provide the API key here at runtime. DO NOT put your actual key here.
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const result = await response.json();
        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
          const text = result.candidates[0].content.parts[0].text;
          addChatMessage(text, 'bot');
        } else {
          console.error("Gemini API response structure unexpected:", result);
          addChatMessage("Sorry, I couldn't get a response from Gemini. Please try again.", 'bot');
        }
      } catch (error) {
        console.error("Error calling Gemini API:", error);
        addChatMessage("An error occurred while connecting to Gemini. Please check your network.", 'bot');
      }
    }

    // --- Music Player Functionality ---
    /**
     * Plays the currently selected music track.
     */
    function playMusic() {
      if (audioPlayer.paused) {
        audioPlayer.play().catch(e => console.error("Error playing audio:", e));
        playPauseMusicBtn.innerHTML = '<i class="fas fa-pause"></i>';
        // Start RGB glow animation (handled by CSS, but ensure music is playing)
        document.querySelector('.rgb-glow-border').style.animationPlayState = 'running';
      }
    }

    /**
     * Pauses the music.
     */
    function pauseMusic() {
      if (!audioPlayer.paused) {
        audioPlayer.pause();
        playPauseMusicBtn.innerHTML = '<i class="fas fa-play"></i>';
        // Pause RGB glow animation
        document.querySelector('.rgb-glow-border').style.animationPlayState = 'paused';
      }
    }

    /**
     * Loads and plays a specific track from the playlist.
     * @param {number} index - The index of the track in the `musicTracks` array.
     */
    function loadTrack(index) {
      if (index < 0 || index >= musicTracks.length) {
        console.warn("Invalid music track index.");
        return;
      }
      currentMusicIndex = index;
      audioPlayer.src = musicTracks[currentMusicIndex].src;
      currentTrackTitle.textContent = musicTracks[currentMusicIndex].title;
      playMusic();

      // Update active class on playlist buttons
      playlistItems.forEach((item, idx) => {
        if (idx === currentMusicIndex) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
    }

    prevMusicBtn.addEventListener('click', () => {
      let newIndex = currentMusicIndex - 1;
      if (newIndex < 0) {
        newIndex = musicTracks.length - 1; // Loop to end
      }
      loadTrack(newIndex);
    });

    nextMusicBtn.addEventListener('click', () => {
      let newIndex = currentMusicIndex + 1;
      if (newIndex >= musicTracks.length) {
        newIndex = 0; // Loop to beginning
      }
      loadTrack(newIndex);
    });

    playPauseMusicBtn.addEventListener('click', () => {
      if (audioPlayer.src) { // Only play/pause if a track is loaded
        if (audioPlayer.paused) {
          playMusic();
        } else {
          pauseMusic();
        }
      } else {
        // If no track is loaded, load the first one and play
        if (musicTracks.length > 0) {
          loadTrack(0);
        } else {
          showCustomAlert("No music tracks available.");
        }
      }
    });

    volumeSlider.addEventListener('input', (e) => {
      audioPlayer.volume = e.target.value;
    });

    // Initial load of the first track (optional, can be played on demand)
    document.addEventListener('DOMContentLoaded', () => {
      if (musicTracks.length > 0) {
        audioPlayer.src = musicTracks[currentMusicIndex].src;
        currentTrackTitle.textContent = musicTracks[currentMusicIndex].title;
        volumeSlider.value = audioPlayer.volume; // Set slider to initial volume
      }
      // Ensure RGB glow is paused initially
      document.querySelector('.rgb-glow-border').style.animationPlayState = 'paused';
    });

    // Event listeners for playlist items
    playlistItems.forEach((item, index) => {
      item.addEventListener('click', () => loadTrack(index));
    });


    // --- Pomodoro Timer Functionality ---
    /**
     * Updates the Pomodoro timer display.
     */
    function updatePomodoroDisplay() {
      const minutes = Math.floor(pomodoroTimeLeft / 60);
      const seconds = pomodoroTimeLeft % 60;
      pomodoroTimerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    /**
     * Starts the Pomodoro timer.
     */
    function startPomodoro() {
      if (isPomodoroRunning) return;
      if (pomodoroTimeLeft === 0 || pomodoroTimeLeft === undefined) { // If timer finished or not set, set to default
        pomodoroTimeLeft = 25 * 60; // Default to 25 minutes
        updatePomodoroDisplay();
      }

      isPomodoroRunning = true;
      startPomodoroBtn.classList.add('hidden');
      pausePomodoroBtn.classList.remove('hidden');
      resetPomodoroBtn.classList.remove('hidden');

      pomodoroInterval = setInterval(() => {
        pomodoroTimeLeft--;
        updatePomodoroDisplay();

        if (pomodoroTimeLeft <= 0) {
          clearInterval(pomodoroInterval);
          isPomodoroRunning = false;
          showCustomAlert("Pomodoro session complete! Take a break.");
          startPomodoroBtn.classList.remove('hidden');
          pausePomodoroBtn.classList.add('hidden');
          resetPomodoroBtn.classList.remove('hidden'); // Keep reset visible after completion
        }
      }, 1000);
    }

    /**
     * Pauses the Pomodoro timer.
     */
    function pausePomodoro() {
      if (!isPomodoroRunning) return;
      clearInterval(pomodoroInterval);
      isPomodoroRunning = false;
      startPomodoroBtn.classList.remove('hidden');
      pausePomodoroBtn.classList.add('hidden');
    }

    /**
     * Resets the Pomodoro timer to the last selected preset or default.
     */
    function resetPomodoro() {
      clearInterval(pomodoroInterval);
      isPomodoroRunning = false;
      // Find the active preset or default to 25 minutes
      const activePreset = document.querySelector('.timer-preset-btn.active');
      const defaultTime = activePreset ? parseInt(activePreset.dataset.time) : 25;
      pomodoroTimeLeft = defaultTime * 60;
      updatePomodoroDisplay();
      startPomodoroBtn.classList.remove('hidden');
      pausePomodoroBtn.classList.add('hidden');
      resetPomodoroBtn.classList.add('hidden'); // Hide reset until started again
    }

    startPomodoroBtn.addEventListener('click', startPomodoro);
    pausePomodoroBtn.addEventListener('click', pausePomodoro);
    resetPomodoroBtn.addEventListener('click', resetPomodoro);

    // Event listeners for preset buttons
    timerPresetBtns.forEach(btn => {
      btn.addEventListener('click', (e) => {
        timerPresetBtns.forEach(p => p.classList.remove('active')); // Remove active from all
        e.target.classList.add('active'); // Add active to clicked
        pausePomodoro(); // Pause if running
        pomodoroTimeLeft = parseInt(e.target.dataset.time) * 60;
        updatePomodoroDisplay();
        startPomodoroBtn.classList.remove('hidden'); // Ensure start button is visible
        pausePomodoroBtn.classList.add('hidden');
        resetPomodoroBtn.classList.add('hidden'); // Hide reset button
      });
    });

    // Initialize Pomodoro display
    document.addEventListener('DOMContentLoaded', () => {
      // Set 25 min as active by default
      const defaultPresetBtn = document.querySelector('.timer-preset-btn[data-time="25"]');
      if (defaultPresetBtn) {
        defaultPresetBtn.classList.add('active');
      }
      pomodoroTimeLeft = 25 * 60; // Initial time in seconds
      updatePomodoroDisplay();
    });

    // --- End of VibeRoom Specific JavaScript ---
  </script>
</body>
</html>
